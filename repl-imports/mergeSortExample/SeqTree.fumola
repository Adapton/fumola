//
// 2025-05-26 -- Playing with some ideas for a collections library.
// This code's status is still "sketch", not something nailed down. 
//
module { 
  public type Binary<X> = {
    symbol : Symbol;
    left : Pointer<SeqTree<X>>;
    right : Pointer<SeqTree<X>>;
  };

  public type Element<X> = {
    element : X;
    symbol : Symbol;
  };

  public type SeqTree<X> = {
    #empty;
    #element : Element<X>;
    #binary : Binary<X>;
  };

  func fromIterRec<X>(iter : Iter<(Symbol, X)>, left : Pointer<SeqTree<X>>, parentLevel : Nat) : Pointer<SeqTree<X>> {
    switch (iter.next()) {
      case null left;
      case (?(symbol, element)) {
         let level = prim "symbolLevel" symbol;
         if (level <= parentLevel) {
           let rightLeft = symbol-`element := #element {symbol; element};
           let right = fromIterRec(iter, rightLeft, level);
           let left = symbol-`binary := #binary {symbol; left; right};
           fromIterRec(iter, left, parentLevel)
         } else {
           left
         }
      };
      case otherwise {
         (prim "print") otherwise;
         error
      };
    }
  };

  public func fromIter<X>(iter : Iter<(Symbol, X)>) : ?Pointer<SeqTree<X>> {
    do ? {
      let (symbol, element) = iter.next() ! ;
      (prim "print") symbol;
      let level = prim "symbolLevel" symbol;
      (prim "print") level;
      fromIterRec(iter, symbol-`element := #element {symbol; element}, level)
    }
  };

  public func fromArray<X>(array : [(Symbol, X)]) : ?Pointer<SeqTree<X>> {
    fromIter(array.vals())
  };
};
