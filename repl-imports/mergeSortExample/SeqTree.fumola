module { 
  #[listing]
  public type SeqTree<X> = {
    #empty;
    #element : Element<X>;
    #binary : Binary<X>;
  };
  #[listing]
  public type SeqTree_<X> = Pointer<SeqTree<X>>;

  #[listing]
  public type Binary<X> = {
    symbol : Symbol;
    level : Nat;
    left : SeqTree_<X>;
    right : SeqTree_<X>;
  };

  #[listing]
  public type Element<X> = {
    element : X;
    symbol : Symbol;
  };

  #[listing]
  public type List<X> = ?{
    element : X;
    symbol : Symbol;
    next : Pointer<List<X>>;
  };

  public func listFromIter(iter : Iter<(Symbol, X)>) : List<X> {
    switch (iter.next()) {
      case null null;
      case (?(symbol, element)) {
        ?{symbol; element; next=listFromIter(iter)}
      }
    } 
  };

  public func listFromIterTest() {
    let list = listFromIter([(1,1), (2,2), (3,3)].vals());
    assert (list!.symbol == 1);
    assert (list!.element == 1);
    assert (list!.next!.symbol == 2);
    assert (list!.next!.element == 2);
    assert (list!.next!.next!.symbol == 3);
    assert (list!.next!.next!.element == 3);
    assert (list!.next!.next!.next == null);
  };

  public func fromArray<X>(array : [(Symbol, X)]) : ?SeqTree_<X> {
    fromList(listFromIter(array.vals()))
  };

  #[listing]
  public func fromList<X>(list : List<X>) : ?SeqTree_<X> {
    do ? {
      let {symbol; element; next} = list!;
      let level = prim "symbolLevel" symbol;
      let (tree, nil) = fromListRec(next, symbol-`element := #element {symbol; element}, null);
      assert (nil == null);
      tree
    }
  };

  #[listing]
  func levelLte(level : Nat, parentLevel : ?Nat) : bool {
    switch parentLevel {
      case null true;
      case (?p) level <= p;
    }
  };

  #[listing]
  func fromListRec<X>(list : List<X>, left : SeqTree_<X>, parentLevel : ?Nat) : (SeqTree_<X>, List<X>) {
    switch list {
      case null (left, null);
      case (?{symbol; element; next}) {
        let level = prim "symbolLevel" symbol;
        if (levelLte(level, parentLevel)) {
          let rightLeft = symbol-`element := #element {symbol; element};
          let (right, next) = force (symbol-`rec1 := thunk { fromListRec(next, rightLeft, ?level) });
          let left = symbol-`binary := #binary {symbol; level; left; right};
          force ( symbol-`rec2 := thunk { fromListRec(next, left, parentLevel) } );
        } else {
          (left, list)
        }
      };
    }
  };

  func max(a, b) {
    if (a > b) { a } else { b }
  };

  func indentText(n : Nat) : Text {
    if (n == 0) { "" } else {
      "  " # (indentText(n - 1))
    }
  };

  // WIP -- this syntax for tikz is approximate for now.
  public func tikzText<X>(tree : Pointer<SeqTree<X>>, n : Nat) : Text {
    switch (@ tree) {
      case (#empty) { "emptyNode\n" };
      case (#element(e)) {
        indentText(n) # "node[element node] {\n" #
        indentText(n + 1) # "\\matrix {\n" #
        indentText(n + 2) # "\\node[symbol field] {" # (debug_show e.symbol) # "}; \\\\\n" #
        indentText(n + 2) # "\\node[element field] {" # (debug_show e.element) # "}; \\\\\n" #
        indentText(n + 1) # "};\n" #
        indentText(n) # "}\n" 
      };
      case (#binary(b)) { 
        indentText(n) # "node[binary node] {\n" #
        indentText(n + 1) # "\\matrix {\n" #
        indentText(n + 2) # "\\node[symbol field] {" # (debug_show b.symbol) # "}; \\\\\n" #
        indentText(n + 2) # "\\node[level field] {" # (debug_show b.level) # "}; \\\\\n" #
        indentText(n + 1) # "};\n" #
        indentText(n + 1) # "child {\n" #
        tikzText(b.left, n + 2) # 
        indentText(n + 1) # "}\n" #
        indentText(n + 1) # "child {\n" #
        tikzText(b.right, n + 2) #
        indentText(n + 1) # "}\n" #
        indentText(n) # "}\n" 
      };
    }
  };

  public func writeTikzText<X>(path : Symbol, tree : ?Pointer<SeqTree<X>>) {
    let ?() = do ? {
      prim "writeFile" (path, tikzText(tree!, 0))
    };
  };

  #[listing]
  public func metrics<X>(tree : Pointer<SeqTree<X>>) {
    switch (@ tree) {
      case (#empty) { { depth=0; size=0 } };
      case (#element(e)) { { depth=1; size=1 } };
      case (#binary(b)) {
        let ml = metrics(b.left);
        let mr = metrics(b.right);
        { 
          depth = max(ml.depth, mr.depth) + 1; 
          size = ml.size + mr.size 
        }
      };
    }
  }

};
