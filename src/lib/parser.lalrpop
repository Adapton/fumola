use std::str::FromStr;
//use std::collections::HashMap;
use num_bigint::{BigInt, BigUint};
use crate::ast::{Id, Exp, Exp_, Literal, Case, Dec};

grammar;

pub Exp_: Exp_ = {
    Exp => Box::new(<>)
};

pub Exp: Exp = {
    "return" <e:Exp_> => Exp::Return(e),
    Literal => Exp::Literal(<>),
};

pub Literal: Literal = {
    "null" => Literal::Null,
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    "()" => Literal::Unit,
    r"-?[0-9]+\.[0-9]+" => Literal::Float(<>.to_string()), // TODO: possibly use JSON parser for float and string literals?
    r"[0-9]+" => Literal::Nat(BigUint::from_str(<>).unwrap()), // maybe refactor to use Nat parser?
    r"-[0-9]+" => Literal::Int(BigInt::from_str(<>).unwrap()),
    r"'([^']|')'" => Literal::Char(<>.chars().nth(<>.len() - 2).unwrap()), // TODO: more test cases
    r#""(?:[^\\"]|\.)*""# => Literal::Text(<>[1..<>.len() - 1].to_string()), // TODO more test cases
    // TODO: Blob?
    // TODO: Pre?
}

pub Nat: usize = {
    r"[0-9]+" => <>.parse::<usize>().unwrap(),
}

pub Id: Id = {
    r"[a-zA-Z][a-zA-Z_0-9]*" => String::from_str(<>).unwrap()
};





// ----- Matthew's work space

pub ExpPlain_: Exp_ = {
    ExpPlain => Box::new(<>),
};

pub ExpPlain: Exp = {
    Literal => Exp::Literal(<>),
    "(" <es:Exps> ")" => { es.reverse(); Exp::Tup(es) },
};

pub Exps: Vec<Exp> = {
    Exp => vec!(<>),
    <e:Exp> "," <es:Exps> => { es.push(e); es },
}

pub ExpNullary_: Exp_ = {
    ExpNullary => Box::new(<>),
};

pub ExpNullary: Exp = {
    ExpPlain => <>,
    Id => Exp::Id(<>),
};

pub ExpPost_: Exp_ = {
    ExpPost => Box::new(<>),
};

pub ExpPost: Exp = {
    ExpNullary => <>,
    <e1:ExpPost_> "[" <e2:Exp_> "]" => Exp::Index(e1, e2),
    <e1:ExpPost_> "." <i:Nat32> => Exp::Proj(e1, i),
    <e1:ExpPost_> "." <i:Id> => Exp::Dot(e1, i),
    <e:ExpPost_> "!" => Exp::Bang(e),
};

pub ExpNonDec: Exp = {
    ExpBin => <>,
    <e1:ExpBin_> ":=" <e2:Exp_> => Exp::Assign(e1, e2),
    "return" => Exp::Return(Box::new(Exp::Literal(Literal::Unit))),
    "return" <e:Exp_> => Exp::Return(e),
    "switch" <e:ExpNullary_> "{" <cs:Cases> "}" => { cs.reverse(); Exp::Switch(e, cs) },
    "ignore" <e:ExpNest_> => Exp::Ignore(e),
}

pub TextId: String = {
   r"[a-zA-Z][a-zA-Z_0-9]*" => String::from_str(<>).unwrap()
}

pub Cases: Cases = {
    Case => vec!(<>),
    <c:Case> ";" <mut cs:Cases> => { cs.push(c); cs }
}

pub Decs: Decs = {
    Dec => vec!(<>),
    <d:Dec> ";" <mut ds: Decs> => { ds.push(d); ds }
};

pub Dec: Dec = {
    "let" <i:Id> "=" <e:Exp_> => { Dec::Let(Pat::Var(i), e) },s
};

pub Case: Case = {
    "case" <pat:Pat> <exp:ExpNest> => Exp::Case(Case{pat, exp}),
};
