use std::str::FromStr;
//use std::collections::HashMap;
use crate::util::get_one;
use crate::ast::{Id, Pat, Exp, Exp_, Type, Type_, PrimType, Literal, Case, Cases, Decs, Dec, UnOp, BinOp, Delim};

grammar;

// Terminals

pub NatIndex: usize = {
    r"[0-9]+" => <>.parse().unwrap(),
}

pub Id: Id = {
    r"[a-zA-Z][a-zA-Z_0-9]*" => String::from_str(<>).unwrap()
};

// --- Helper Functions --- //

/// One or more `T`s, delimited by interposed separator `S`.
Delim1<T, S>: Delim<T> = {
    T => {
        Delim{ vec:vec!(<>), has_trailing: false }
    },
    <mut v:(<T> S)+> <e:T?> => match e {
        None => {
            Delim{ vec:v, has_trailing: true }
        },
        Some(e) => {
            v.push(e);
            Delim{ vec:v, has_trailing: false }
        }
    }
};

/// Zero or more `T`s, delimited by interposed separator `S`.
Delim0<T, S>: Delim<T> = {
    <mut v:(<T> S)*> <e:T?> => match e {
        None => {
            Delim{ vec:v, has_trailing: true }
        },
        Some(e) => {
            v.push(e);
            Delim{ vec:v, has_trailing: false }
        }
    }
};

// --- Literals --- //

pub Literal: Literal = {
    "null" => Literal::Null,
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    "(" ")" => Literal::Unit,
    r"-?([0-9]+\.[0-9]*|([0-9]*\.[0-9]+))" => Literal::Float(<>.to_string()), // TODO: possibly use JSON parser for float and string literals?
    r"-[0-9]+" => Literal::Int(<>.to_string()),
    r"[0-9]+" => Literal::Nat(<>.to_string()),
    r"'([^']|')'" => Literal::Char(<>.chars().nth(<>.len() - 2).unwrap()), // TODO: more test cases
    r#""(?:[^\\"]|\.)*""# => Literal::Text(<>[1..<>.len() - 1].to_string()), // TODO more test cases
}

// --- Patterns --- //

pub PatPlain: Pat = {
    "_" => Pat::Wild,
    Id => Pat::Var(<>),
    Literal => Pat::Literal(<>),
    "(" <ps:Delim1<PatBin, ",">> ")" => get_one(ps).map(Pat::Paren).unwrap_or_else(Pat::Tuple),
}

pub PatNullary: Pat = {
    PatPlain,
    // to do -- copy more cases from parser.mly
}

pub PatBin: Pat = {
    PatUn,
    // to do -- copy more cases from parser.mly
}

pub PatUn: Pat = {
    PatNullary,
    "#" <s:Id> => Pat::Variant(s, None),
    "#" <s:Id> <p:PatNullary> => Pat::Variant(s, Some(Box::new(p))),
}

// pub Pat_: Pat_ = {
//     Pat => Box::new(<>),
// }

// pub Pat: Pat = {
//     <ps:Delim1<PatBeforeAlt, "|">> => Pat::Alt(ps),
// }

// pub PatBeforeType: Pat = {
//     "_" => Pat::Wild,
//     Id => Pat::Var(<>),
//     Literal => Pat::Literal(<>),
//     // TODO: Signed(Vec<UnOp>, Pat_)
//     "(" <ps:Delim1<Pat, ",">> ")" => get_one(ps).unwrap_or_else(Pat::Tuple),
//     // TODO: Object(Vec<(Id, Pat)>)
//     "?" <p:PatBeforeType> => Pat::Optional(Box::new(p)),
//     "#" <s:Id> ":" <p:PatBeforeType?> => Pat::Variant(s, Box::new(p.unwrap_or(Pat::Wild))), // should we allow whitespace after '#' symbol?
// }

// pub PatBeforeAlt: Pat = {
//     PatBeforeType,
//     <p:PatBeforeType> <t:TypeAnnot> => Pat::Annot(Box::new(p), t),
// }

// --- Types --- //

pub TypeAnnot: Type = {
    ":" <t:Type> => t,
}

pub PrimType: PrimType = {
    "(" ")" => PrimType::Unit,
    "Bool" => PrimType::Bool,
    "Nat" => PrimType::Nat,
    "Nat8" => PrimType::Nat8,
    "Nat16" => PrimType::Nat16,
    "Nat32" => PrimType::Nat32,
    "Nat64" => PrimType::Nat64,
    "Int" => PrimType::Int,
    "Int8" => PrimType::Int8,
    "Int16" => PrimType::Int16,
    "Int32" => PrimType::Int32,
    "Int64" => PrimType::Int64,
    "Principal" => PrimType::Principal,
    "Text" => PrimType::Text,
}

pub Type_: Type_ = {
    Type => Box::new(<>),
}

pub Type: Type = {
    PrimType => Type::Prim(<>),
    // TODO
}

// --- Expressions --- //

pub Exp_: Exp_ = {
    Exp => Box::new(<>)
}

pub Exp: Exp = {
    ExpPlain,
    ExpNonDec,
}

pub ExpPlain_: Exp_ = {
    ExpPlain => Box::new(<>),
}

pub ExpPlain: Exp = {
    Literal => Exp::Literal(<>),
    "(" <es:Delim1<Exp, ",">> ")" => get_one(es).map(Exp::Paren).unwrap_or_else(Exp::Tuple),
}

pub ExpNullary_: Exp_ = {
    ExpNullary => Box::new(<>),
}

pub ExpNullary: Exp = {
    ExpPlain => <>,
    Id => Exp::Var(<>),
}

pub ExpPost_: Exp_ = {
    ExpPost => Box::new(<>),
}

pub ExpPost: Exp = {
    ExpNullary => <>,
    <e1:ExpPost_> "[" <e2:Exp_> "]" => Exp::Idx(e1, e2),
    <e1:ExpPost_> "." <i:NatIndex> => Exp::Proj(e1, i),
    <e1:ExpPost_> "." <i:Id> => Exp::Dot(e1, i),
    <e:ExpPost_> "!" => Exp::Bang(e),
}

pub ExpNonDec: Exp = {
//    ExpUn => <>,
//    ExpBin => <>,
//    <e1:ExpBin_> ":=" <e2:Exp_> => Exp::Assign(e1, e2),
    "return" => Exp::Return(Box::new(Exp::Literal(Literal::Unit))),
    "return" <e:Exp_> => Exp::Return(e),
    "switch" <e:ExpNullary_> "{" <cs:Cases> "}" => { Exp::Switch(e, cs) },
    "ignore" <e:ExpNest_> => Exp::Ignore(e),
}

pub ExpNest_: Exp_ = {
    ExpBin => Box::new(<>),
}

pub ExpNest: Exp = {
    // to do -- Block
    Exp => <>,
}

pub ExpUn_: Exp_ = {
    ExpUn => Box::new(<>),
}

pub ExpUn: Exp = {
    ExpPost => <>,
    <u:UnOp> <e:ExpUn_> => Exp::Un(u, e),
    "not" <e:ExpUn_> => Exp::Not(e),
}

pub ExpBin_: Exp_ = {
    ExpBin => Box::new(<>),
}

pub ExpBin: Exp = {
    <e1:Exp_> <b:BinOp> <e2:ExpBin_> => Exp::Bin(e1, b, e2),
}

pub TextId: String = {
   r"[a-zA-Z][a-zA-Z_0-9]*" => String::from_str(<>).unwrap()
}

pub Cases: Cases = {
    Delim0<Case, ";">
}

pub Case: Case = {
    "case" <pat:PatNullary> <exp:ExpNest> => Case{pat, exp},
}

pub Decs: Decs = {
    Delim0<Dec, ";">
}

pub Dec: Dec = {
    "let" <i:Id> "=" <e:Exp> => Dec::Let(Pat::Var(i), e),
}

pub UnOp: UnOp = {
    "+" => UnOp::Pos,
    "-" => UnOp::Neg,
    "^" => UnOp::Not,
}

pub BinOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
    "**" => BinOp::Pow,
    "+%" => BinOp::WAdd,
    "-%" => BinOp::WSub,
    "*%" => BinOp::WMul,
    "**%" => BinOp::WPow,
    "&" => BinOp::And,
    "|" => BinOp::Or,
    "^" => BinOp::Xor,
    "<<" => BinOp::ShL,
//    " >>" => BinOp::Shr,
    "<<>" => BinOp::RotL,
    "<>>" => BinOp::RotR,
    "#" => BinOp::Cat,
}
