use std::str::FromStr;
//use std::collections::HashMap;
use num_bigint::{BigInt, BigUint};
use crate::ast::{Id, Pat, Exp, Exp_, Literal, Case, Cases, Decs, Dec, BinOp};

grammar;

pub Exp_: Exp_ = {
    Exp => Box::new(<>)
};

pub Exp: Exp = {
    "return" <e:Exp_> => Exp::Return(e),
    Literal => Exp::Literal(<>),
};

pub Literal: Literal = {
    "null" => Literal::Null,
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    "()" => Literal::Unit,
    r"-?[0-9]+\.[0-9]+" => Literal::Float(<>.to_string()), // TODO: possibly use JSON parser for float and string literals?
    r"[0-9]+" => Literal::Nat(BigUint::from_str(<>).unwrap()), // maybe refactor to use Nat parser?
    r"-[0-9]+" => Literal::Int(BigInt::from_str(<>).unwrap()),
    r"'([^']|')'" => Literal::Char(<>.chars().nth(<>.len() - 2).unwrap()), // TODO: more test cases
    r#""(?:[^\\"]|\.)*""# => Literal::Text(<>[1..<>.len() - 1].to_string()), // TODO more test cases
    // TODO: Blob?
    // TODO: Pre?
}

pub NatIndex: usize = {
    r"[0-9]+" => <>.parse::<usize>().unwrap(),
}

pub Id: Id = {
    r"[a-zA-Z][a-zA-Z_0-9]*" => String::from_str(<>).unwrap()
};





// ----- Matthew's work space

pub ExpPlain_: Exp_ = {
    ExpPlain => Box::new(<>),
};

pub ExpPlain: Exp = {
    Literal => Exp::Literal(<>),
    "(" <mut es:Exps> ")" => { es.reverse(); Exp::Tup(es) },
};

pub Exps: Vec<Exp> = {
    Exp => vec!(<>),
    <e:Exp> "," <mut es:Exps> => { es.push(e); es },
}

pub ExpNullary_: Exp_ = {
    ExpNullary => Box::new(<>),
};

pub ExpNullary: Exp = {
    ExpPlain => <>,
    Id => Exp::Var(<>),
};

pub ExpPost_: Exp_ = {
    ExpPost => Box::new(<>),
};

pub ExpPost: Exp = {
    ExpNullary => <>,
    <e1:ExpPost_> "[" <e2:Exp_> "]" => Exp::Idx(e1, e2),
    <e1:ExpPost_> "." <i:NatIndex> => Exp::Proj(e1, i),
    <e1:ExpPost_> "." <i:Id> => Exp::Dot(e1, i),
    <e:ExpPost_> "!" => Exp::Bang(e),
};

pub ExpNonDec: Exp = {
    ExpBin => <>,
    <e1:ExpBin_> ":=" <e2:Exp_> => Exp::Assign(e1, e2),
    "return" => Exp::Return(Box::new(Exp::Literal(Literal::Unit))),
    "return" <e:Exp_> => Exp::Return(e),
    "switch" <e:ExpNullary_> "{" <mut cs:Cases> "}" => { cs.reverse(); Exp::Switch(e, cs) },
    "ignore" <e:ExpNest_> => Exp::Ignore(e),
}

pub ExpNest_: Exp_ = {
    ExpBin => Box::new(<>),
};

pub ExpNest: Exp = {
    // to do -- Block
    Exp => <>,
};

pub ExpBin_: Exp_ = {
    ExpBin => Box::new(<>),
};

pub ExpBin: Exp = {
    <e1:Exp_> <b:BinOp> <e2:ExpBin_> => Exp::Bin(e1, b, e2),
}

pub TextId: String = {
   r"[a-zA-Z][a-zA-Z_0-9]*" => String::from_str(<>).unwrap()
}

pub Cases: Cases = {
    Case => vec!(<>),
    <c:Case> ";" <mut cs:Cases> => { cs.push(c); cs }
}

pub Decs: Decs = {
    Dec => vec!(<>),
    <d:Dec> ";" <mut ds: Decs> => { ds.push(d); ds }
};

pub Dec: Dec = {
    "let" <i:Id> "=" <e:Exp> => Dec::Let(Pat::Var(i), e),
};

pub Case: Case = {
    "case" <i:Id> <exp:ExpNest> => Case{pat:Pat::Var(i), exp},
};

pub BinOp: BinOp = { 
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
    "**" => BinOp::Pow,
    "+%" => BinOp::WAdd,
    "-%" => BinOp::WSub,
    "*%" => BinOp::WMul,
    "**%" => BinOp::WPow,
    "&" => BinOp::And,
    "|" => BinOp::Or,
    "^" => BinOp::Xor,
    "<<" => BinOp::ShL,
//    " >>" => BinOp::Shr,
    "<<>" => BinOp::RotL,
    "<>>" => BinOp::RotR,
    "#" => BinOp::Cat,
};
